\subsection{Codigo de testing de la solucion provista}

En primera instancia, se realizaran pruebas de solidez y correctitud de las restricciones implementadas. Por último, tests de correctitud de las consultas requeridas por el enunciado. El codigo de los tests de restricciones se encuentra en 'tests.sql'

\subsubsection{Votos de una eleccion}

Verificaremos la conjuncion de las restricciones "Todos los votos para una eleccion son: o bien consulta popular o bien de tipo candidato según corresponda el tipo de eleccion",  "Si la eleccion es una consulta popular, los votos deben ser si/no. sino, deben ser candidatos'' y por ultimo, ''Un voto a candidato, debe referenciar a un candidato postulado para dicha eleccion''

\begin{enumerate}

\item \textbf{Consulta Popular:} Si la eleccion es una consulta popular, los votos cuya clave foranea
referencia esa eleccion deben ser de tipo ' A Plesbiscito Si ' o ' A Plesbiscito No'. Creamos una elección de tipo 'Consulta Popular' utilizando la Stored Procedure 'Crear\_ Consulta\_ Popular' con los valores Descripcion: TEST y Fecha: '2015-06-09'. 

A continuacion, debemos crear una mesa. Para eso, debemos tener un presidente, un vicepresidente,
un centro y una maquina(y para ella, un tecnico). Las creamos ejecutando:

\begin{lstlisting}

INSERT INTO Ciudadano VALUES
 (1,'JUAN','VOTANTE'),
 (2,'PEPE','PRESIDENTE'),
 (3,'VICTOR','VICEPRESIDENTE'),
 (4,'TOMAS','TECNICO'),
 
 INSERT INTO Centro VALUES
 (1,'Escuela', '9 de julio 1');

 INSERT INTO Maquina VALUES
 (1,4);

 INSERT INTO Mesa VALUES
 (1,1,2,3,1,1,1);
\end{lstlisting}

	\begin{itemize}
	\item 'A Plesbiscito Si': Insertar un voto 'A Plesbiscito Si' deberia realizarse correctamente. (En todos los casos, al terminar el test borramos el voto)
	Ejecutamos la Stored Procedure 'Votar\_ Consulta\_ Popular' con los parametros DNIdelVotante=1, idEleccion=1 y OpcionVoto=1. Acto seguido, ejecutamos:
	\begin{lstlisting}
	SELECT * FROM Voto
	\end{lstlisting}
	Y efectivamente esto nos da como resultado:	
	\vspace{2mm}
	
	\begin{tabular}{| l| l| l| l| }
	\hline 
	   & idVoto & idMesa & Tipo \\
	   \hline
	 1 & 1 & 1 & A Plesbiscito Si \\
 	 \hline 
	\end{tabular}
	
	\vspace{2mm}
	\item 'A Plesbiscito No': Insertamos un voto de tipo 'A Plesbiscito No', lo cual deberia ejecutarse correctamente, usando la Stored Procedure 'Votar\_ Consulta\_ Popular' con los parametros DNIdelVotante=1, idEleccion=1 y OpcionVoto=0. Resultado:
	
	\begin{tabular}{| l| l| l| l| }
	\hline 
	   & idVoto & idMesa & Tipo \\
	   \hline
	 1 & 1 & 1 & A Plesbiscito No \\
 	 \hline 
	\end{tabular}
	
	\vspace{2mm}	
	
	\item 'Voto de tipo invalido': Insertamos un voto de tipo invalido, lo cual NO deberia ejecutarse correctamente, usando la Stored Procedure 'Votar\_ Consulta\_ Popular' con los parametros DNIdelVotante=1, idEleccion=1 y OpcionVoto=3 (Esto representa un tipo de voto invalido). Resultado:
	
\begin{tabular}{| l| l| l| l| }
	\hline 
	   & idVoto & idMesa & Tipo \\
	   \hline
	 &  &  &  \\
 	 \hline 
	\end{tabular}
	
	\vspace{2mm}	
		
	
	\item 'Voto a un candidato': Insertamos un voto 'A Candidato' lo cual NO deberia ejecutarse correctamente, usando la Stored Procedure 'Votar\_ Candidato' sobre la Consulta Popular, con los parametros DNIdelVotante=1, idEleccion=1 y DniCandidato=5. Inmediatamente recibimos el aviso:
	''La eleccion es para Consulta Popular pero el voto no es a plesbicito''. y como resultado:
		
\begin{tabular}{| l| l| l| l| }
	\hline 
	   & idVoto & idMesa & Tipo \\
	   \hline
	 &  &  &  \\
 	 \hline 
	\end{tabular}
	
	\vspace{2mm}	
	\end{itemize}
\item \textbf{Eleccion a candidato:}  Si la eleccion es de tipo 'Cargo Federal', 'Cargo Municipal', Cargo Provincial' o tipo 'Cargo Legislativo', los votos cuya clave foranea referencia esa eleccion deben ser de tipo 'A Candidato', y deben referenciar a un candidato que este postulado a dicha eleccion. Vamos a crear una eleccion provincial, debemos crear una provincia, un partido, y postular a 'CARLOS CANDIDATO' a la eleccion.
\begin{lstlisting}
	 INSERT INTO Ciudadano VALUES
	(5,'CARLOS', 'CANDIDATO');
 
  	INSERT INTO Candidato VALUES
 	(5);

	INSERT INTO Provincia VALUES
 	(1,'BUENOS AIRES');
 	 
 	INSERT INTO Partido_Politico VALUES
	(1,'FRENTE POR LA APROBACION');
	
	INSERT INTO Postulaciones VALUES
	(1,5,1)
	\end{lstlisting}
	
Eliminamos la anterior eleccion, de forma de poder usar la misma mesa y sus encargados, y usamos la Stored Procedure 'Crear\_ Eleccion\_ Provincial', con los parametros idProvincia=1 y fecha='2015-06-10'.

	\begin{itemize}
	\item 'Candidato Valido': Insertamos un voto de tipo 'A candidato', cuya clave foranea a candidato referencia a un candidato cuyo DNI se encuentra en la tabla postulaciones para esa eleccion, lo cual deberia ejecutarse sin problemas. Usamos la Stored Procedure: 'Votar\_ Candidato' con los parametros: DNIVotante=1, idEleccion=1, DNICandidato=5.Si ejecutamos:
	\begin{lstlisting}
	SELECT * FROM Voto
	\end{lstlisting}
	
	Obtenemos:
	
	\begin{tabular}{| l| l| l| l| }
	\hline 
	   & idVoto & idMesa & Tipo \\
	   \hline
	 1 & 1 & 1 & A Candidato \\
 	 \hline 
	\end{tabular}
	\vspace{2mm}	
	
	Y si ejecutamos: 
	
	\begin{lstlisting}
	SELECT * FROM Voto_A_Candidato
	\end{lstlisting}
	
	Obtenemos:
	
	\begin{tabular}{| l| l|}
	\hline 
	   idVoto & DNI \\
	   \hline
	 1 & 5  \\
 	 \hline 
	\end{tabular}
	\vspace{2mm}
	
	\item 'Candidato Invalido': e insertamos un voto de tipo 'A candidato', cuya clave foranea a candidato NO referencia a un candidato cuyo DNI se encuentra en la tabla postulaciones para esa eleccion. Esto no deberia ser aceptable. Para esto creamos otro ciudadano:
	\begin{lstlisting}
	 INSERT INTO Ciudadano VALUES
 	(6,'IGNACIO','IMPOSTOR');
	\end{lstlisting}
	
	Usamos la Stored Procedure: 'Votar\_ Candidato' con los parametros: DNIVotante=1, idEleccion=1, DNICandidato=6. Obtenemos un aviso: 'Instrucción INSERT en conflicto con la restricción FOREIGN KEY "FK\_Voto\_ A\_ Candidato\_ Candidato'. Y los resultados de consultar la tabla Voto y la tabla Voto\_ A\_ Candidato son:
	
	
	\begin{tabular}{| l| l| l| l| }
	\hline 
	   & idVoto & idMesa & Tipo \\
	  \hline 
	   & & & \\
	   \hline 
	\end{tabular}
	\vspace{2mm}	
	
	
	\begin{tabular}{| l| l|}
	\hline 
	idVoto & DNI \\
	\hline 
	 & \\
	\hline 
	\end{tabular}
		
	\item 'Voto a plesbiscito': Insertamos un voto
	de tipo 'A plesbiscito Si', lo cual no deberia ejecutarse. Ejecutamos la Stored Procedure 'Votar\_ Consulta\_ Popular' con los parametros DNIdelVotante=1, idEleccion=1 y OpcionVoto=1. Obtenemos el aviso: ''La eleccion es para Cargo pero el voto no es a candidato'', y como resultados:
	
	\begin{tabular}{| l| l| l| l| }
	\hline 
	   & idVoto & idMesa & Tipo \\
	  \hline 
	   & & & \\
	   \hline 
	\end{tabular}
	\vspace{2mm}	
	
	
	\begin{tabular}{| l| l|}
	\hline 
	idVoto & DNI \\
	\hline 
	 & \\
	\hline 
	\end{tabular}
			
	\end{itemize}
\end{enumerate}
\subsubsection{Multiples Candidatos:} Un partido politico puede presentar a un solo candidato por eleccion. Para chequear esto, vamos a intentar postular a ambos 'CARLOS CANDIDATO' e 'IGNACIO IMPOSTOR' al partido 'Frente por la Aprobacion'. No deberia ejecutarse. Al ejecutar esto, obtenemos el aviso: ''Infracción de la restricción UNIQUE KEY 'Unique\_ Key\_ Eleccion\_ Partido''. Si consultamos la tabla postulaciones, nos devuelve:
\vspace{2mm}
	
	\begin{tabular}{| l| l| l|}
	\hline 
	idEleccion & DNI & idPartido \\
	\hline 
	 1 & 5 & 1 \\
	\hline 
	\end{tabular}
\vspace{2mm}
Con lo que efectivamente, no se inserto el segundo candidato.

\subsubsection{Multiples Mesas para un ciudadano:} Un ciudadano solo vota en una mesa por eleccion. Para comprobar eso creamos otro presidente, vicepresidente, tecnico y maquina para poder crear otra mesa, e intentamos asignar en el Padron a 'PEPE VOTANTE' ambas mesas.
	\begin{lstlisting}
	INSERT INTO Ciudadano VALUES
	(7,'TITO','TECNICODOS'),
	(8,'PEDRO','PRESIDENTEDOS'),
	(9,'VALENTIN','VICEPRESIDENTEDOS');
	
	INSERT INTO Maquina VALUES
 	(2,7);
 	
 	 INSERT INTO Mesa VALUES
 	(2,2,8,9,1,1,2)
 
	\end{lstlisting}
	\vspace{2mm}		
	Y finalmente, asignamos al ciudadano a ambas mesas
	\vspace{2mm}
	\begin{lstlisting}
	Insert INTO Padron VALUES
	(1,1,NULL)
	(1,2,NULL)
	\end{lstlisting}
	
	\vspace{2mm}
	
	A lo que recibimos el aviso: ''Ya existe una mesa en la cual esta persona vota en esta eleccion''. Y si consultamos el padron, obtenemos:
	
	\vspace{2mm}
	
	\begin{tabular}{| l| l| l|}
	\hline 
	DNI & idMesa & selloVoto \\
	\hline 
	 1 & 1 & NULL \\
	\hline 
	\end{tabular}
	\vspace{2mm}
	
	Efectivamente solo se asigno la primera vez.
	
\subsubsection{Multiples Mesas para una  maquina:} Una maquina solo funciona en una mesa por eleccion. Para esto eliminamos la segunda mesa que creamos en el test anterior, y la vamos a crear de nuevo pero asignandole la misma maquina 1.
	\begin{lstlisting}
	 DELETE FROM Mesa 
 	 WHERE idMesa=2
 	 
 	 
 INSERT INTO Mesa VALUES
 	  (2,2,8,9,1,1,1);
	\end{lstlisting}
			\vspace{2mm}				
Obtenemos el aviso: ''Ya existe una mesa en esta eleccion con esta maquina'', y si consultamos la tabla Mesa vemos que efectivamente no se agrego la segunda:
			\vspace{2mm}	
			
	\begin{tabular}{| l| l| l| l| l| l| l|}
	\hline 
	idMesa & nroMesa & idPresidente & idVicePresidente & idEleccion & idCentro & idMaquina \\
	\hline 
	 1 & 1 & 2 & 3 & 1 & 1 & 1 \\
	\hline 
	\end{tabular}
	
	\vspace{2mm}	
			
\subsubsection{Validaciones de los votos}: Validaremos las restricciones: ''No permitir que la gente vote mas de una vez por eleccion'', ''El voto puede hacerse en la fecha de la eleccion de 8am a 6pm''. 
	\begin{itemize}
	\item 'Unico voto': Creamos un partido politico para el Candidato 'IGNACIO IMPOSTOR' y lo postulamos

	\begin{lstlisting}
	INSERT INTO Partido_Politico VALUES
	(2,'UNIDOS POR LA UNION');
	
	
	INSERT INTO Postulaciones VALUES
	(1,5,1);
	(1,6,2);
	\end{lstlisting}

 Usamos dos veces consecutivas la Stored Procedure: 'Votar\_ Candidato' con los parametros: DNIVotante=1, idEleccion=1, DNICandidato=5 en la primera vez, y en la segunda vez: DNIVotante=1, idEleccion=1, DNICandidato=6. Obtenemos el aviso: 'Esta persona ya voto en esta eleccion', y como resultado:
 
 	\vspace{2mm}	
 	
 \begin{tabular}{| l| l| l| l| }
	\hline 
	   & idVoto & idMesa & Tipo \\
	  \hline 
	   &1 &1 & aCandidato \\
	   \hline 
	\end{tabular}
	\vspace{2mm}	
	
		\vspace{2mm}
			
	\begin{tabular}{| l| l|}
	\hline 
	idVoto & DNI \\
	\hline 
	  1 & 5 \\
	\hline 
	\end{tabular}
	
		\vspace{2mm}	
		Donde vemos que solo se inserto el primer voto.
		
	\item 'Hora valida': Creamos una elección de tipo 'Consulta Popular', y hacemos que un ciudadano intente votar en un horario invalido (cambiamos la hora de la computadora a las 19:00hs). Recibimos el aviso:Estamos fuera de horario de votacion, y no se modificaron las tablas de votos.

	
	\end{itemize}					

\subsubsection{Consultas del enunciado}:

Insertamos los siguientes datos en la base para poder realizar los dos primeros tests: 15 ciudadanos, que seran los votantes, dos presidentes, vicepresidentes y tecnicos de mesa, dos candidatos, dos conductores(a estos ultimos, no los hacemos votar, solo hacemos votar a los ciudadanos para que sea mas entendible), dos centros, dos camiones, una provincia y dos partidos. Este codigo se encuentra en el archivo 'testQueries.sql'

\begin{lstlisting}
INSERT INTO Ciudadano VALUES
(1,'CIUDADANO','UNO'),
(2,'CIUDADANO','DOS'),
(3,'CIUDADANO','TRES'),
(4,'CIUDADANO','CUATRO'),
(5,'CIUDADANO','CINCO'),
(6,'CIUDADANO','SEIS'),
(7,'CIUDADANO','SIETE'),
(8,'CIUDADANO','OCHO'),
(9,'CIUDADANO','NUEVE'),
(10,'CIUDADANO','DIEZ'),
(11,'CIUDADANO','ONCE'),
(12,'CIUDADANO','DOCE'),
(13,'CIUDADANO','TRECE'),
(14,'CIUDADANO','CATORCE'),
(15,'CIUDADANO','QUINCE'),
(16,'PRESIDENTEMESA','UNO'),
(17,'PRESIDENTEMESA','DOS'),
(18,'VICEPRESIDENTEMESA','UNO'),
(19,'VICEPRESIDENTEMESA','DOS'),
(20,'TECNICO','UNO'),
(21,'TECNICO','DOS'),
(22,'CANDIDATO','UNO'),
(23,'CANDIDATO','DOS'),
(24,'CANDIDATO','TRES'),
(25,'CANDIDATO','CUATRO'),
(26,'CONDUCTOR','UNO'),
(27,'CONDUCTOR','DOS');

INSERT INTO Centro VALUES
(1,'ESCUELA','UNO'),
(2,'ESCUELA2','DOS');

INSERT INTO Camion VALUES
(1,26),
(2,27);

INSERT INTO Camion_Centro VALUES
(1,1),
(2,2);

INSERT INTO Maquina VALUES
(1,20),
(2,21);

INSERT INTO Candidato VALUES
(22), (23), (24), (25);

INSERT INTO Provincia VALUES
(1,'BUENOS AIRES');

INSERT INTO Partido_Politico VALUES
(1,'PARTIDO DE IZQUIERDA'),
(2,'PARTIDO DE DERECHA');


\end{lstlisting}

\begin{itemize}
\item \textbf{Ganadores de elecciones del ultimo año}
A continuacion creamos dos elecciones, una federal y una provincial. Cambiamos el reloj de la computadora al 1 de enero de 2015 para crear la federal, para poder estar la correctitud del calculo del año corriente, y la provincial se efectua el 12/06/2015. Usamos la Stored Procedure para crear la provincial, y el siguiente codigo para crear la federal:

\begin{lstlisting}
INSERT INTO Eleccion VALUES
(1,GETDATE(),'Cargo Federal');
\end{lstlisting}


A continuacion creamos dos mesas, una en cada centro y para cada eleccion. Acto seguido, postulamos a los primeros dos candidatos a la eleccion del 1ero de enero, uno por el partido de izquierda, el otro por el de derecha. Hacemos lo mismo con el tercer y cuarto candidato, en la eleccion del 12 de junio.

\begin{lstlisting}
INSERT INTO Mesa VALUES
(1,1,16,18,1,1,1);

INSERT INTO Mesa VALUES
(2,2,17,19,2,2,2);

INSERT INTO Postulaciones VALUES
(1,22,1),
(1,23,2),
(2,24,1),
(2,25,2);
\end{lstlisting}

Finalmente, armamos el padron y asignamos a los 15 ciudadanos, la mesa 1 para la primera eleccion y la mesa 2 para la segunda eleccion.

\begin{lstlisting}
INSERT INTO Padron VALUES
(1,1,NULL),
(2,1,NULL),
(3,1,NULL),
(4,1,NULL),
(5,1,NULL),
(6,1,NULL),
(7,1,NULL),
(8,1,NULL),
(9,1,NULL),
(10,1,NULL),
(11,1,NULL),
(12,1,NULL),
(13,1,NULL),
(14,1,NULL),
(15,1,NULL),
(1,2,NULL),
(2,2,NULL),
(3,2,NULL),
(4,2,NULL),
(5,2,NULL),
(6,2,NULL),
(7,2,NULL),
(8,2,NULL),
(9,2,NULL),
(10,2,NULL),
(11,2,NULL),
(12,2,NULL),
(13,2,NULL),
(14,2,NULL),
(15,2,NULL);
\end{lstlisting}

Finalmente, hacemos votar a los ciudadanos. En la primera eleccion, haremos votar 10 al 'CANDIDATO UNO' y los restantes 5 al 'CANDIDATO DOS'. En la segunda eleccion, haremos votar 8 al 'CANDIDATO TRES' y 7 al 'CANDIDATO CUATRO. Hacemos uso de las debidas Stored Procedures. Si consultamos la tabla 'Voto\_ A \_ Candidato':

\vspace{2mm}	
 	
 \begin{tabular}{| l| l|}
	\hline 
	    idVoto & DNI \\
	  \hline 
	   1 &22  \\
	   \hline 
	   2 &22  \\
	   \hline 
	   3 &22  \\
	   \hline 
	   4 &22  \\
	   \hline 
	   5 &22  \\
	   \hline 
	   6 &22  \\
	   \hline 
	   7 &22  \\
	   \hline 
	   8 &22  \\
	   \hline 
	   9 &22  \\
	   \hline 
	   10 &22  \\
	   \hline 
	   11 &23  \\
	   \hline 
	   12 &23  \\
	   \hline 
	   13 &23  \\
	    \hline 
	   14 &23  \\
	   \hline 
	   15 &23  \\
	   \hline 
	   16 &24  \\
	   \hline 
	   17 &24  \\
	   \hline 
	   18 &24  \\
	   \hline 
	   19 &24  \\	 
	     \hline 
	   20 &24  \\	 
	     \hline 
	   21 &24  \\
	   \hline 
	   22 &24  \\	
	      \hline 
	   23 &24  \\	 
	     \hline 
	   24 &25  \\
	   \hline 
	   25 &25  \\	  
	    \hline 
	   26 &25  \\	  
	    \hline 
	   27 &25  \\	  
	    \hline 
	   28 &25  \\	 
	     \hline 
	   29 &25  \\	 
	     \hline 
	   30 &25  \\
	   \hline 
	\end{tabular}
	\vspace{2mm}	

Donde podemos ver que se refleja lo que queriamos. A continuacion ejecutamos la query:


\begin{lstlisting}
WITH WINNERS AS (
	SELECT FechaEleccion, Candidato, CantVotos,
	 ROW_NUMBER() over (
	        PARTITION BY FechaEleccion
	        ORDER BY CantVotos DESC
	    ) AS NumFila
	FROM Ranking_Elecciones_Cargo_Ultimo_Anio

)
SELECT FechaEleccion, Candidato, CantVotos FROM WINNERS WHERE NumFila <= 1--cantidad de items por grupo
\end{lstlisting}


 y esperamos que nos de como resultado 'CANDIDATO UNO' y 'CANDIDATO TRES'. Resultado:
 
 \begin{tabular}{| l| l| l| }
	\hline 
	    fechaEleccion & Candidato & CantVotos \\
	   \hline
	  '2015-01-01' & CANDIDATOUNO & 10 \\
 	 \hline 
 	   '2015-06-12' & CANDIDATOTRES & 8 \\
 	 \hline 
	\end{tabular}
	
	\vspace{2mm}	


\item \textbf{Ultimas personas que fueron a votar por Centro}

Por la forma en las que ejecutamos las Stored Procedures(votaron del 1 al 15 en orden en la primera, y luego del 1 al 15 en orden en la segunda), la query deberia devolvernos los ciudadanos desde el 11 al 15 para cada eleccion. Ejecutamos el codigo de la consulta:

\begin{lstlisting}
		WITH TOPFIVE AS (
	    SELECT cen.Nombre_Establecimiento, (ciu.Nombre + ciu.Apellido) as Votante, p.selloVoto as HoraVoto,
	    ROW_NUMBER() over (
	        PARTITION BY cen.idCentro
	        ORDER BY p.selloVoto DESC
	    ) AS NumFila
	    FROM Padron p
	    INNER JOIN Mesa m ON m.idMesa = p.idMesa
	    INNER JOIN Centro cen ON cen.idCentro = m.idCentro
	    INNER JOIN Ciudadano ciu ON ciu.DNI = p.DNI
	    
	SELECT Nombre_Establecimiento, Votante, HoraVoto FROM TOPFIVE WHERE NumFila <= 5--cantidad de items por grupo
	\end{lstlisting}

Y la consulta nos da como resultado:


 \begin{tabular}{| l| l| l|}
	\hline 
	    Nombre\_ Establecimiento & Votante & HoraVoto \\
	  \hline 
	   ESCUELA &CIUDADANOQUINCE & 2015-01-01 15:31:45.777 \\
	   \hline 
	   ESCUELA &CIUDADANOCATORCE & 2015-01-01 15:31:39.827 \\
	   \hline 
	   ESCUELA &CIUDADANOTRECE & 2015-01-01 15:31:33.407 \\
	   \hline 
	  ESCUELA  & CIUDADANODOCE & 2015-01-01 15:31:19.793\\
	   \hline 
	   ESCUELA  & CIUDADANOONCE & 2015-01-01 15:30:54.793\\
	   \hline 
	   ESCUELA2 &CIUDADANOQUINCE & 2015-06-12 15:34:20.013 \\
	   \hline 
	   ESCUELA2 &CIUDADANOCATORCE & 2015-06-12 15:34:15.037 \\
	   \hline 
	   ESCUELA2  & CIUDADANOTRECE &2015-06-12 15:34:11.063 \\
	   \hline 
	   ESCUELA2  & CIUDADANODOCE &2015-06-12 15:34:05.987 \\
	   \hline 
	   ESCUELA2  & CIUDADANOONCE &2015-06-12 15:34:02.407 \\
	   \hline 
	\end{tabular}

\item \textbf{Partidos pol\'i ticos con mas del 20\% en las ultimas 5 elecciones}

Para este test, insertamos un conjunto de datos mas extenso, que se encuentra en el archivo 'TESTCONSULTATRES.sql'. En resumen, se crearon 6 elecciones a gobernador, 12 mesas (2 por eleccion), 12 candidatos (2 por eleccion) y 5 partidos, y se completaron las demas tablas para que todo esto funcione (maquina, tecnico, etc.) Acto seguido, se ejecuto la Stored Procedure de voto de esta forma:

\begin{enumerate}
	\item \textbf{Eleccion 1:} Candidato uno (Partido de izquierda):10 votos (66\%). Candidato dos (Partido de derecha): 5 votos (33\%). 
	\item \textbf{Eleccion 2:} Candidato tres (Partido de izquierda):10 votos (66\%). Candidato cuatro (Partido de derecha): 5 votos (33\%).
	\item \textbf{Eleccion 3:} Candidato cinco (Partido de izquierda):10 votos (66\%). Candidato seis (partido de centro): 5 votos (33\%).
-- Candidato 44 tiene 10 votos, candidato 45 tiene 5
	\item \textbf{Eleccion 4:} Candidato siete (Partido de izquierda):10 votos (66\%). Candidato ocho (Frente por la aprobacion): 5 votos (33\%).
	\item \textbf{Eleccion 5:} Candidato nueve(Frente por la aprobacion): 15 votos (100\%). Candidato diez (Unidos por la Union): 0 votos (0\%).
	\item \textbf{Eleccion 6:} Candidato once(Frente por la aprobacion): 15 votos (100\%). Candidato doce (Unidos por la Union): 0 votos (0\%).

\end{enumerate}

Esperamos que la query ignore la primera eleccion (ya que se consideran las ultimas 5 elecciones), y que aparezcan en ella el Partido de Izquierda, el Partido de Derecha, el Partido de Centro y el Frente por la Aprobacion. El partido Unidos por la Union no deberia formar parte del resultado, ya que saco menos del 20\% en todas sus elecciones. Ejecutamos la query y obtenemos como resultado:



 \begin{tabular}{| l| l| l|}
	\hline 
	    FechaEleccion & PartidoPolitico & Porcentaje \\
	  \hline 
	   2015-07-02 &PARTIDO DE IZQUIERDA & 66 \\
	   \hline 
	   2015-07-02 &PARTIDO DE DERECHA  & 33 \\
	   \hline 
	   2015-07-03 &PARTIDO DE IZQUIERDA  & 66 \\
	   \hline 
	  2015-07-03  & PARTIDO DE CENTRO  & 33\\
	   \hline 
	   2015-07-04  & PARTIDO DE IZQUIERDA  & 66\\
	   \hline 
	   2015-07-04 &FRENTE POR LA APROBACION & 33 \\
	   \hline 
	   2015-07-05 &FRENTE POR LA APROBACION & 100 \\
	   \hline 
	   2015-07-06  & FRENTE POR LA APROBACION &100 \\
	   \hline 
	\end{tabular}

Efectivamente, devuelve lo esperado.

\end{itemize}